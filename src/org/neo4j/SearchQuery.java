/*********************************************************************************************************************************************************************
 * @Author: 	Neo4J Team
 * @Course: 	z517 - Web Programming
 * @Date: 		20th April, 2014
 * @Description:Contains the implementation for querying the DB for required data. 	
 ***********************************************************************************************************************************************************************/

package org.neo4j;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.ws.rs.core.MediaType;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;

public class SearchQuery {

	List<Long>dependentTweets;

	public SearchQuery() {
		// TODO Auto-generated constructor stub
		dependentTweets = new ArrayList<Long>();
	}
	
	/**
	 * This method directs a cypher query to a REST service. The REST service responds with the matching nodes' information.
	 * The response is filtered to construct a JSON format that can be parsed by the d3.js team.
	 * @param originalQuery The cypher query constructed to locate each tweet and its related nodes
	 * @return a map of the tweet JSONObject mapped to its dependent nodes (JSONArray)
	 * @SuppressWarnings("unchecked")
	 */
	public Map<JSONObject,JSONArray> query(String originalQuery){
		
		WebResource resource = Client.create().resource( "http://localhost:7474/db/data/cypher" );
		String query = JSONObject.escape(originalQuery);
		ClientResponse cypherResponse = resource.accept( MediaType.APPLICATION_JSON ).type( MediaType.TEXT_PLAIN )
				.entity( "{\"query\" : \""+query+"\", \"params\" : {}}" )
				.post( ClientResponse.class );
		String cypherResult = cypherResponse.getEntity( String.class );
		cypherResponse.close();
		
		// convert the cypherResult to a JSONObject
		JSONObject obj = (JSONObject)JSONValue.parse(cypherResult);
		
		/*fetch the "data" content of 'obj' into a 'data' variable which is 
		in fact a JSONArray of JSONArrays that further contain JSONObjects each having their own "data" field*/  
		JSONArray data = (JSONArray)obj.get("data");

		JSONArray send  = new JSONArray();
		Map<JSONObject, JSONArray> toSend = new HashMap<JSONObject, JSONArray>();
		JSONObject jsonOriginal = new JSONObject();
		for(int x=0; x < data.size(); x++){
			
			// extract each JSONArray in 'data' one by one
			JSONArray fieldData = (JSONArray) data.get(x);
			
			// each 'fieldData' JSONArray contains two JSONObjects with their respective "data" fields in them
			jsonOriginal = (JSONObject) fieldData.get(0);						// tweet content related JSONObject
			JSONObject objSingle = (JSONObject) fieldData.get(1);				// dependent node content related JSONObject
			
			// collect each dependent node's "data" content and store it one by one in the 'send' JSONArray
			send.add((JSONObject) objSingle.get("data"));

		}
		
		// finally, fill the HashMap 'toSend' with a tweetNode mapped against its dependent nodes' "data" and send it across
		toSend.put((JSONObject) jsonOriginal.get("data"), send);
		return toSend;
	}

	/**
	 * This method takes a list of messageIDs as input. The messageIDs are generated and forwarded to this method by 
	 * the Lucene API. Each messageID corresponds to the tweet that matches the search parameters selected by the user 
	 * in the Lucene user interface. 
	 * @param messgIDList List of message IDs generated by the Lucene API
	 * @return a JSONArray that contains all relevant node information in the form of JSONObjects
	 * @SuppressWarnings("unchecked")
	 */
	
	
	public JSONArray getInitialJSONArray(List<Long> messgIDList){
		JSONArray arraySend = new JSONArray();
		JSONObject tweetnode=null;
		for(Iterator<Long> iterator=messgIDList.iterator();iterator.hasNext();){
			Long singleMessgID=iterator.next();
			String cypherQuery="START n=node(*) where n.MessageID="+singleMessgID+" match n<-[r]->m RETURN distinct n,m";
	
			try{
				Map<JSONObject,JSONArray> finalData=query(cypherQuery);
				for(Map.Entry<JSONObject, JSONArray> entry:finalData.entrySet())
					arraySend.add(entry.getKey());				
			}
			catch(NullPointerException e){		
			}
		}
		return arraySend;
	}
	
	
	
	public JSONArray getJsonFromMessageList(List<Long> messgIDList, String relType, long startTime, long endTime){
		Map<String, JSONObject> dependentNodesMap = new HashMap<String, JSONObject>();
		JSONArray arraySend = new JSONArray();
		JSONObject tweetnode = null;
		for (Iterator<Long> iterator = messgIDList.iterator(); iterator.hasNext();) {
			Long singleMessgID =  iterator.next();
			//String cypherQuery = "START n=node(*) WHERE n.MessageID=" + singleMessgID + " MATCH n<-[r]->m RETURN DISTINCT n,m";
			
			String cypherQuery="START n=node(*) where n.MessageID="+singleMessgID+" MATCH n<-[:`"+relType+"`]->m where m.TimeStamp>="+startTime+" AND m.TimeStamp<="
					+endTime+" RETURN DISTINCT n,m";
					
			try{
			Map<JSONObject, JSONArray> finalData = query(cypherQuery);
			System.out.println("final Data "+finalData);
			
			JSONArray depends = new JSONArray();
			
			// retrieve each tweet and its related nodes to construct the final JSONArray
			for (Map.Entry<JSONObject, JSONArray> m : finalData.entrySet()) {
				//System.out.println(m.getKey());
				tweetnode  = m.getKey();
				tweetnode.put("type", "tweet");
				depends = m.getValue();
			}
			List<String> dependsData = new ArrayList<String>();
			
			/* iterate over the 'depends' JSONArray to construct classified JSONObjects ("tweet", "username", etc.) 
			as per the final json format */
			for(int i=0;i<depends.size();i++){
				
				JSONObject element = (JSONObject) depends.get(i);
				if (element.containsKey("Message")) {
					element.put("type", "tweet");
					dependentTweets.add((Long)element.get("id"));
					
					// replace "id" field in 'element' by "name" field
					element.remove("id");
					element.put("name", element.get("MessageID")+"");
					
				} else if (element.containsKey("UserNameKey")) {
					element.put("type", "username");
					
					// replace "id" field in 'element' by "name" field
					element.remove("id");
					element.put("name", element.get("UserNameKey"));
				} else if (element.containsKey("HashTagKey")){
					String hashTagKey= "#"+element.get("HashTagKey");
					element.put("type", "hashtag");
					element.put("HashTagKey", hashTagKey);

					// replace "id" field in 'element' by "name" field
					element.remove("id");
					element.put("name", hashTagKey);
					//System.out.println(element);
					//System.exit(0);
				}
				
				// map each dependent node "name" (MessageID, hashtag name, username) to its own node
				dependentNodesMap.put(element.get("name")+"",element);
				
				// store each dependent node's "name" in order to append it to its respective parent tweet node 
				dependsData.add(element.get("name")+"");
			}
//			System.out.println(dependsData);
			
			// append 'dependsData' to each parent tweet node
			tweetnode.put("depends", dependsData);
			
			// start constructing the final JSONArray which has all tweets' information first 
			arraySend.add(tweetnode);
			}
			catch (NullPointerException e) {
				// TODO: handle exception
			}
		}
		
		// add all previously tracked dependent nodes to the final JSONArray that already contains tweet nodes information only
		for(Map.Entry<String, JSONObject> entry : dependentNodesMap.entrySet()) {
			arraySend.add( entry.getValue());
		}
		
		return arraySend;

	}
	
	/**
	 * This method writes a JSONArray to a text file. The JSONArray is the one that is constructed after a cypher query 
	 * is forwarded to the REST service. The cypher query asks the graph database for a set of nodes that match 
	 * the specified conditions. The response from the REST service is then converted to a JSONArray format.  
	 * @param jObj the argument is the final JSONArray that needs to be written to a text file
	 * @return void
	 */
	public void writeJsonToFile(JSONArray jObj) {
		File file = new File("D:\\iub\\sem2\\web programming\\project\\data.txt");

		try {
			if (!file.exists()) {
				file.createNewFile();
			}

			FileWriter fw = new FileWriter(file.getAbsoluteFile());
			BufferedWriter bw = new BufferedWriter(fw);
			bw.write(jObj.toJSONString());
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	/*	@SuppressWarnings("unchecked")
	public JSONArray getJsonFromMessageListFromDependent(List<Long> messgIDList, JSONArray initial){
		JSONArray array =  getJsonFromMessageList(messgIDList);
		for(int i = 0 ;i < initial.size();i++)
			for(int j =0 ; j<array.size();j++){
				if(initial.get(i)==array.get(j));
				else
					initial.add(array.get(j));
			}
		return initial;
	}*/

	public JSONObject diffuseSeedNodes (List<Long> seedMsgIDs, String relType, long startTime, long endTime) {
		JSONObject sendBranchNodes = new JSONObject();

		// hard-code relType = IS_A_RETWEETOF for now
		relType = "IS_A_RETWEETOF";

		String cypherQuery = null;

		for (Iterator itr = seedMsgIDs.iterator(); itr.hasNext();) {
			Long singleSeedMsgID = (Long) itr.next();

			// construct query to diffuse each node per relationship type selected
			
			
			cypherQuery="START n=node(*) where n.MessageID="+singleSeedMsgID+" MATCH n<-[:`"+relType+"`]->m where m.TimeStamp>="+startTime+" AND m.TimeStamp<="
			+endTime+" RETURN DISTINCT n,m";
			//cypherQuery = "START " +
				//	"n=node(*) WHERE n.MessageID=" + singleSeedMsgID + " MATCH n<-[:" + relType + "]->m " +
				//	"WHERE m.TimeStamp>" + startTime + " AND m.TimeStamp<=" + endTime + " RETURN DISTINCT n,m"; 

			Map<JSONObject, JSONArray> branchNodesMap = query(cypherQuery);

			for (Map.Entry<JSONObject, JSONArray> m : branchNodesMap.entrySet()) {

			}

		}

		return sendBranchNodes;
	}
}